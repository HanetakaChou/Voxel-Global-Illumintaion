//
// Copyright (C) YuqiaoZhang(HanetakaChou)
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//

#ifndef _BRX_VOXEL_CONE_TRACING_VOXELIZATION_FRAGMENT_BSLI_
#define _BRX_VOXEL_CONE_TRACING_VOXELIZATION_FRAGMENT_BSLI_ 1

#include "../include/brx_voxel_cone_tracing.h"

#if 0

#ifndef BRX_VCT_CLIPMAP_OPACITY_TEXTURE
#error "BRX_VCT_CLIPMAP_OPACITY_TEXTURE must be defined to point to a Texture3D<uint> type resource"
#endif

#ifndef BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE
#error "BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE must be defined to point to a Texture3D<uint> type resource"
#endif

#endif

#define INTERNAL_BRX_VCT_VOXELIZATION_PIXEL_MAXIMUM_VOXEL_COUNT 3

#define INTERNAL_BRX_VCT_CLIPMAP_VOXEL_DIRECTION_COUNT 6

void brx_voxel_cone_tracing_voxelization_store_data(
    brx_int in_viewport_depth_direction_index,
    brx_int in_clipmap_stack_level_index,
    brx_float3 in_viewport_depth_direction_texel_space,
    brx_uint in_sample_mask,
    brx_float in_opacity,
    brx_float3 in_shading_normal_world_space,
    brx_float3 in_diffuse_color,
    brx_float3 in_specular_color,
    brx_float in_roughness,
    brx_float3 in_incident_direction,
    brx_float3 in_incident_illumination)
{
    brx_float3 texel_space;
    brx_int3 offset_direction;
    brx_branch if (BRX_VCT_VIEWPORT_DEPTH_DIRECTION_AXIS_Z == in_viewport_depth_direction_index)
    {
        texel_space = brx_float3(in_viewport_depth_direction_texel_space.x, in_viewport_depth_direction_texel_space.y, in_viewport_depth_direction_texel_space.z);
        offset_direction = brx_int3(0, 0, 1);
    }
    else if (BRX_VCT_VIEWPORT_DEPTH_DIRECTION_AXIS_Y == in_viewport_depth_direction_index)
    {
        texel_space = brx_float3(in_viewport_depth_direction_texel_space.y, in_viewport_depth_direction_texel_space.z, in_viewport_depth_direction_texel_space.x);
        offset_direction = brx_int3(0, 1, 0);
    }
    else
    {
        // assert(BRX_VCT_VIEWPORT_DEPTH_DIRECTION_AXIS_X == in_viewport_depth_direction_index)
        texel_space = brx_float3(in_viewport_depth_direction_texel_space.z, in_viewport_depth_direction_texel_space.x, in_viewport_depth_direction_texel_space.y);
        offset_direction = brx_int3(1, 0, 0);
    }

    // \[Takeshige 2015\] [Masaya Takeshige. "The Basics of GPU Voxelization." NVIDIA GameWorks Blog 2015.](https://developer.nvidia.com/content/basics-gpu-voxelization)
    // the same pixel may intersecting multiple voxels in the viewport depth direction
    const brx_int voxel_coordinates_offsets[INTERNAL_BRX_VCT_VOXELIZATION_PIXEL_MAXIMUM_VOXEL_COUNT] = brx_array_constructor_begin(brx_int, INTERNAL_BRX_VCT_VOXELIZATION_PIXEL_MAXIMUM_VOXEL_COUNT) - 1 brx_array_constructor_split 0 brx_array_constructor_split 1 brx_array_constructor_end;
    brx_float opacity_sample_scale[INTERNAL_BRX_VCT_VOXELIZATION_PIXEL_MAXIMUM_VOXEL_COUNT] = brx_array_constructor_begin(brx_float, INTERNAL_BRX_VCT_VOXELIZATION_PIXEL_MAXIMUM_VOXEL_COUNT) 0.0 brx_array_constructor_split 0.0 brx_array_constructor_split 0.0 brx_array_constructor_end;
    {
        const brx_float viewport_depth_direction_texel_space_relative_z_centers[INTERNAL_BRX_VCT_VOXELIZATION_PIXEL_MAXIMUM_VOXEL_COUNT] = brx_array_constructor_begin(brx_float, INTERNAL_BRX_VCT_VOXELIZATION_PIXEL_MAXIMUM_VOXEL_COUNT) - 0.5 brx_array_constructor_split 0.5 brx_array_constructor_split 1.5 brx_array_constructor_end;

#if 8 == BRX_VCT_VOXELIZATION_PIXEL_SAMPLE_COUNT
        // "Standard Sample Patterns" https://learn.microsoft.com/en-us/windows/win32/api/d3d11/ne-d3d11-d3d11_standard_multisample_quality_levels
        // "Standard Sample Locations" https://registry.khronos.org/vulkan/specs/1.0/html/chap25.html#primsrast-multisampling
        const brx_float2 sample_positions[BRX_VCT_VOXELIZATION_PIXEL_SAMPLE_COUNT] =
            brx_array_constructor_begin(brx_float2, BRX_VCT_VOXELIZATION_PIXEL_SAMPLE_COUNT)
            brx_float2(0.0625, -0.1875) brx_array_constructor_split
            brx_float2(-0.0625, 0.1875) brx_array_constructor_split
            brx_float2(0.3125, 0.0625) brx_array_constructor_split
            brx_float2(-0.1875, -0.3125) brx_array_constructor_split
            brx_float2(-0.3125, 0.3125) brx_array_constructor_split
            brx_float2(-0.4375, 0.0625) brx_array_constructor_split
            brx_float2(0.1875, 0.4375) brx_array_constructor_split
            brx_float2(0.4375, -0.4375)
            brx_array_constructor_end;
#else
#error
#endif

        // \[Takeshige 2015\] [Masaya Takeshige. "The Basics of GPU Voxelization." NVIDIA GameWorks Blog 2015.](https://developer.nvidia.com/content/basics-gpu-voxelization)
        // If (the absolute value of) either of these gradients "ddx(depth) or ddy(depth)" exceeds 1.0, then the voxelized plane will have "cracks" in a direction perpendicular to the depth direction.
        brx_float2 delta_z = brx_float2(brx_ddx(in_viewport_depth_direction_texel_space.z), brx_ddy(in_viewport_depth_direction_texel_space.z));
        // assert(dZ <= float2(1.0, 1.0))

        brx_float fraction_z = brx_frac(in_viewport_depth_direction_texel_space.z);

        brx_unroll for (brx_int sample_index = 0; sample_index < brx_int(BRX_VCT_VOXELIZATION_PIXEL_SAMPLE_COUNT); ++sample_index)
        {
            if (0 != (in_sample_mask & (1u << sample_index)))
            {
                brx_float relative_z = fraction_z + brx_dot(delta_z, sample_positions[sample_index]);

                brx_unroll for (brx_int voxel_index = 0; voxel_index < brx_int(INTERNAL_BRX_VCT_VOXELIZATION_PIXEL_MAXIMUM_VOXEL_COUNT); ++voxel_index)
                {
                    opacity_sample_scale[voxel_index] += (1.0 / brx_float(BRX_VCT_VOXELIZATION_PIXEL_SAMPLE_COUNT)) * brx_clamp(1.0 - brx_abs(relative_z - viewport_depth_direction_texel_space_relative_z_centers[voxel_index]), 0.0, 1.0);
                }
            }
        }
    }

    brx_float opacity_area_scale;
    {
        brx_float3 geometry_abs_normal = brx_abs(brx_normalize(brx_cross(brx_ddx(texel_space), brx_ddy(texel_space))));
        opacity_area_scale = 1.0 / brx_max(geometry_abs_normal.x, brx_max(geometry_abs_normal.y, geometry_abs_normal.z));
    }

    for (brx_int voxel_index = 0; voxel_index < brx_int(INTERNAL_BRX_VCT_VOXELIZATION_PIXEL_MAXIMUM_VOXEL_COUNT); ++voxel_index)
    {
        brx_int3 voxel_coordinates = brx_int3(texel_space) + offset_direction * voxel_coordinates_offsets[voxel_index];

        brx_branch if (brx_all(voxel_coordinates >= brx_int3(0, 0, 0)) && brx_all(voxel_coordinates < brx_int3(BRX_VCT_CLIPMAP_MAP_SIZE, BRX_VCT_CLIPMAP_MAP_SIZE, BRX_VCT_CLIPMAP_MAP_SIZE)))
        {
            // TODO: remove this
            voxel_coordinates = int3(VxgiGetToroidalAddress(voxel_coordinates, g_VxgiVoxelizationCB.ToroidalOffset.xyz >> in_clipmap_stack_level_index, g_VxgiVoxelizationCB.ClipLevelSize.xyz));

            brx_float opacity = saturate(in_opacity * opacity_sample_scale[voxel_index] * opacity_area_scale);

            brx_branch if (opacity > 0.0)
            {
                brx_int3 opacity_address = voxel_coordinates + brx_int3(0, 0, (brx_int(BRX_VCT_CLIPMAP_MAP_SIZE) + brx_int(BRX_VCT_CLIPMAP_MARGIN)) * in_clipmap_stack_level_index + 1);
                InterlockedAdd(u_Opacity[opacity_address], brx_uint(opacity * 1023));
            }

            brx_float3 N = in_shading_normal_world_space;
            brx_float3 L = in_incident_direction;
            brx_float NdotL = brx_dot(N, L);

            brx_branch if ((opacity > 0.0) && (NdotL > 0.0) && brx_all(in_incident_illumination > brx_float3(0.0, 0.0, 0.0)))
            {
                brx_int3 address = voxel_coordinates + brx_int3(2, 0, (brx_int(BRX_VCT_CLIPMAP_MAP_SIZE) + brx_int(BRX_VCT_CLIPMAP_MARGIN)) * (in_clipmap_stack_level_index >> 1) + 1);

                // PBR Book V3: [Figure 14.14](https://pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/The_Light_Transport_Equation#BasicDerivation)
                // PBR Book V4: [Figure 13.1](https://pbr-book.org/4ed/Light_Transport_I_Surface_Reflection/The_Light_Transport_Equation)
                // L_current = - V_previous
                const brx_float3 view_directions[INTERNAL_BRX_VCT_CLIPMAP_VOXEL_DIRECTION_COUNT] =
                    brx_array_constructor_begin(brx_float3, INTERNAL_BRX_VCT_CLIPMAP_VOXEL_DIRECTION_COUNT)
                    // 0
                    brx_float3(1.0, 0.0, 0.0) brx_array_constructor_split
                    // 1
                    brx_float3(0.0, 1.0, 0.0) brx_array_constructor_split
                    // 2
                    brx_float3(0.0, 0.0, 1.0) brx_array_constructor_split
                    // 3
                    brx_float3(-1.0, 0.0, 0.0) brx_array_constructor_split
                    // 4
                    brx_float3(0.0, -1.0, 0.0) brx_array_constructor_split
                    // 5
                    brx_float3(0.0, 0.0, -1.0)
                    brx_array_constructor_end;

                brx_unroll for (brx_int view_direction_index = 0; view_direction_index < brx_int(INTERNAL_BRX_VCT_CLIPMAP_VOXEL_DIRECTION_COUNT); ++view_direction_index)
                {
                    brx_float3 V = view_directions[view_direction_index];
                    brx_float NdotV = brx_dot(N, V);

                    brx_branch if (NdotV >= 0.0)
                    {
                        brx_float3 diffuse_brdf = brx_normalized_clamped_cosine_brdf(in_diffuse_color);
                        brx_float3 specular_brdf;
                        {
                            brx_float VdotL = brx_dot(V, L);

                            // Real-Time Rendering Fourth Edition / 9.8 BRDF Models for Surface Reflection / [Hammon 2017]
                            //
                            // |L + V|^2 = L^2 + V^2 + 2L·V = 1 + 1 + 2L·V
                            // N·H = N·((L + V)/(|L + V|)) = (N·L + N·V)/(|L + V|)
                            // L·H = L·((L + V)/(|L + V|)) = (L^2 + L·V)/(|L + V|)
                            // V·H = V·((L + V)/(|L + V|)) = (L·V + V^2)/(|L + V|)
                            // 2L·H = 2V·H = L·H + V·H = (L^2 + L·V + L·V + V^2)/(|L + V|) = (|L + V|^2)/(|L + V|) = |L + V| = 1 + 1 + 2L·V
                            // ⇒ L·H = 0.5 * |L + V| = (0.5 * |L + V|^2)/(|L + V|) =(0.5 * (1 + 1 + 2L·V))/(|L + V|) = 1/(|L + V|) + (L·V)/(|L + V|)
                            //
                            // UE4: [Init](https://github.com/EpicGames/UnrealEngine/blob/4.27/Engine/Shaders/Private/BRDF.ush#L31)
                            // U3D: [GetBSDFAngle](https://github.com/Unity-Technologies/Graphics/blob/v10.8.0/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl#L361)
                            brx_float invLenH = brx_rsqrt(2.0 + 2.0 * VdotL);
                            brx_float NdotH = brx_clamp((NdotL + NdotV) * invLenH, 0.0, 1.0);
                            brx_float LdotH = brx_clamp(invLenH * VdotL + invLenH, 0.0, 1.0);

                            brx_float VdotH = LdotH;

                            // Prevent the roughness to be zero
                            // https://github.com/EpicGames/UnrealEngine/blob/4.27/Engine/Shaders/Private/CapsuleLightIntegrate.ush#L94
                            const brx_float cvar_global_min_roughness_override = 0.02;
                            brx_float roughness = brx_max(in_roughness, cvar_global_min_roughness_override);

                            // Prevent the NdotV to be zero
                            // https://github.com/EpicGames/UnrealEngine/blob/4.27/Engine/Shaders/Private/BRDF.ush#L34
                            NdotV = brx_max(NdotV, 1e-5);

                            // Real-Time Rendering Fourth Edition / 9.8.1 Normal Distribution Functions: "In the Disney principled shading model, Burley[214] exposes the roughness control to users as g = r2, where r is the user-interface roughness parameter value between 0 and 1."
                            brx_float alpha = roughness * roughness;

                            brx_float3 f0 = in_specular_color;
                            const brx_float3 f90 = brx_float3(1.0, 1.0, 1.0);

                            specular_brdf = brx_trowbridge_reitz_brdf(alpha, NdotH, NdotV, NdotL, f0, f90, VdotH);
                        }

                        // photon mapping
                        //
                        // DeltaPhiArea = VoxelSizeWorld * VoxelSizeWorld
                        //
                        // E_n = E_l * NdotL
                        //
                        // DeltaPhi = E_n * DeltaPhiArea
                        //
                        // L = 1 / KernalArea * brdf * DeltaPhi = 1 / (SampleSizeWorld * SampleSizeWorld) * brdf * E_l * NdotL * VoxelSizeWorld * VoxelSizeWorld
                        //
                        // we pre-calculate "brdf * E_l * NdotL" here
                        //
                        brx_float3 delta_phi_div_square_voxel_size = in_incident_illumination * NdotL;
                        brx_float3 diffuse_brdf_mul_delta_phi_div_square_voxel_size = diffuse_brdf * delta_phi_div_square_voxel_size;
                        brx_float3 specular_brdf_mul_delta_phi_div_square_voxel_size = specular_brdf * delta_phi_div_square_voxel_size;

                        // TODO:
                        // we view the voxel as 3x3 octahedral map

                        int3 channelAddress = address;
                        float3 emittanceFrontOrBack = (diffuse_brdf_mul_delta_phi_div_square_voxel_size + specular_brdf_mul_delta_phi_div_square_voxel_size) * opacity;
                        uint3 packedEmittance = VxgiPackEmittanceForAtomic(emittanceFrontOrBack);

                        if (VxgiIsOdd(in_clipmap_stack_level_index))
                        {
                            InterlockedAdd(u_EmittanceOdd[channelAddress], packedEmittance.r);
                            channelAddress.y += int(g_VxgiVoxelizationCB.ChannelStride);
                            InterlockedAdd(u_EmittanceOdd[channelAddress], packedEmittance.g);
                            channelAddress.y += int(g_VxgiVoxelizationCB.ChannelStride);
                            InterlockedAdd(u_EmittanceOdd[channelAddress], packedEmittance.b);
                        }
                        else
                        {
                            InterlockedAdd(u_EmittanceEven[channelAddress], packedEmittance.r);
                            channelAddress.y += int(g_VxgiVoxelizationCB.ChannelStride);
                            InterlockedAdd(u_EmittanceEven[channelAddress], packedEmittance.g);
                            channelAddress.y += int(g_VxgiVoxelizationCB.ChannelStride);
                            InterlockedAdd(u_EmittanceEven[channelAddress], packedEmittance.b);
                        }
                    }

                    address.x += (brx_int(BRX_VCT_CLIPMAP_MAP_SIZE) + brx_int(BRX_VCT_CLIPMAP_MARGIN));
                }
            }

            // TODO: remove this
            {

                bool writeOpacity = (opacity > 0.0);

                bool writeEmittance = ((opacity > 0.0) && (NdotL > 0.0) && brx_all(in_incident_illumination > brx_float3(0.0, 0.0, 0.0)));

                int4 translation = g_VxgiVoxelizationCB.TextureToAmapTranslation[in_clipmap_stack_level_index];
                int3 pageCoordinates = int3(((voxel_coordinates >> translation.w) + translation.xyz) & (g_VxgiVoxelizationCB.AllocationMapSize.xyz - 1));

                uint newPage = u_AllocationMap[pageCoordinates].x;

                if (writeOpacity || writeEmittance)
                    newPage |= 0x01;
                if (writeEmittance)
                    newPage |= 0x02;

                InterlockedOr(u_AllocationMap[pageCoordinates], newPage);
            }
        }
    }
}

#endif
